"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[663],{5789:(e,i,a)=>{a.r(i),a.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"tradeoffs","title":"Trade-offs and Challenges","description":"Container Hosting on EC2/Fargate vs. Dockerized Lambda","source":"@site/docs/tradeoffsAndChallenges.md","sourceDirName":".","slug":"/tradeoffs","permalink":"/docs/tradeoffs","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"tradeoffs","sidebar_label":"5. Trade-offs & Challenges","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"4. Architecture","permalink":"/docs/architecture"},"next":{"title":"6. Future Work","permalink":"/docs/futureWorkd"}}');var n=a(4848),s=a(8453);const r={id:"tradeoffs",sidebar_label:"5. Trade-offs & Challenges",sidebar_position:5},o="Trade-offs and Challenges",l={},d=[{value:"Container Hosting on EC2/Fargate vs. Dockerized Lambda",id:"container-hosting-on-ec2fargate-vs-dockerized-lambda",level:2},{value:"ECS with Fargate",id:"ecs-with-fargate",level:3},{value:"Dockerized AWS Lambda",id:"dockerized-aws-lambda",level:3},{value:"Justification for Choosing Lambda",id:"justification-for-choosing-lambda",level:3},{value:"AWS CDK vs. AWS SDK",id:"aws-cdk-vs-aws-sdk",level:2},{value:"AWS SDK",id:"aws-sdk",level:3},{value:"AWS CDK",id:"aws-cdk",level:3},{value:"Justification for Choosing CDK",id:"justification-for-choosing-cdk",level:3},{value:"State Management: Local vs Cloud",id:"state-management-local-vs-cloud",level:2},{value:"Cloud-Based State Management",id:"cloud-based-state-management",level:3},{value:"Local Configuration File",id:"local-configuration-file",level:3}];function c(e){const i={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.header,{children:(0,n.jsx)(i.h1,{id:"trade-offs-and-challenges",children:"Trade-offs and Challenges"})}),"\n",(0,n.jsx)(i.h2,{id:"container-hosting-on-ec2fargate-vs-dockerized-lambda",children:"Container Hosting on EC2/Fargate vs. Dockerized Lambda"}),"\n",(0,n.jsxs)(i.p,{children:["Selecting the appropriate compute layer for model inference was a critical architectural decision for Nimbus, balancing scalability, cost, and operational simplicity. The team evaluated options ranging from traditional container hosting to fully serverless functions, ultimately comparing two primary serverless strategies: ",(0,n.jsx)(i.strong,{children:"AWS Elastic Container Service (ECS) with Fargate"})," and ",(0,n.jsx)(i.strong,{children:"Dockerized AWS Lambda"})," functions."]}),"\n",(0,n.jsx)(i.h3,{id:"ecs-with-fargate",children:"ECS with Fargate"}),"\n",(0,n.jsxs)(i.p,{children:["Using ",(0,n.jsx)(i.strong,{children:"ECS with Fargate"})," offers a serverless compute engine for containers, removing the need to manage underlying EC2 instances directly. This approach provides a familiar container-based workflow, potentially appealing to teams with existing containerization experience. Its advantages include greater flexibility than Lambda in terms of maximum execution duration and more traditional networking configurations."]}),"\n",(0,n.jsxs)(i.p,{children:["However, for Nimbus's specific goals, several drawbacks were identified. Fargate still necessitates managing ECS task definitions and services, introducing a layer of ",(0,n.jsx)(i.strong,{children:"orchestration overhead"})," that contrasts with Nimbus's aim for maximum simplicity. Furthermore, its pricing model (per vCPU/memory per second, often with minimum durations) could prove less cost-effective than Lambda for the highly ",(0,n.jsx)(i.strong,{children:"intermittent, low-traffic workloads"})," anticipated for Nimbus users, potentially incurring costs even during ",(0,n.jsx)(i.strong,{children:"idle periods"}),"."]}),"\n",(0,n.jsx)("figure",{children:(0,n.jsx)("img",{src:"/img/ecsFargatevsLambda.png",className:"image",alt:"image",width:"70%"})}),"\n",(0,n.jsx)(i.h3,{id:"dockerized-aws-lambda",children:"Dockerized AWS Lambda"}),"\n",(0,n.jsxs)(i.p,{children:["The team ultimately selected ",(0,n.jsx)(i.strong,{children:"Dockerized AWS Lambda"})," as the compute layer, determining it aligned most strongly with Nimbus\u2019s core goals of maximizing ",(0,n.jsx)(i.strong,{children:"simplicity"})," and ",(0,n.jsx)(i.strong,{children:"cost-efficiency"})," for users deploying lightweight models. As a fully managed function-as-a-service platform, Lambda entirely abstracts away server and orchestration concerns."]}),"\n",(0,n.jsxs)(i.p,{children:["The key advantages driving this decision were Lambda's ",(0,n.jsx)(i.strong,{children:"automatic scaling"})," based on demand (from zero upwards), its true ",(0,n.jsx)(i.strong,{children:"pay-per-invocation cost model"})," (billed per millisecond, ideal for intermittent traffic), and the elimination of infrastructure management. Crucially, Lambda's support for ",(0,n.jsx)(i.strong,{children:"Docker container images"})," allows users to reliably package complex Python dependencies (like spaCy) using familiar tooling, overcoming traditional deployment package limitations. Additionally, the ",(0,n.jsx)(i.strong,{children:"seamless integration"})," with API Gateway, provisioned via Nimbus's AWS CDK stack, simplifies exposing models as secure HTTP endpoints."]}),"\n",(0,n.jsxs)(i.p,{children:["This choice required accepting certain ",(0,n.jsx)(i.strong,{children:"trade-offs"})," inherent to Lambda. These include the 15-minute maximum execution duration, memory limits (up to 10GB), lack of direct GPU access, and the potential for ",(0,n.jsx)(i.strong,{children:"cold start latency"})," on infrequent invocations."]}),"\n",(0,n.jsx)("figure",{children:(0,n.jsx)("img",{src:"/img/dockerizedLambda.png",className:"image",alt:"dockerized lambda image",width:"30%"})}),"\n",(0,n.jsx)(i.h3,{id:"justification-for-choosing-lambda",children:"Justification for Choosing Lambda"}),"\n",(0,n.jsx)(i.p,{children:"After evaluating both options, the Dockerized Lambda approach was chosen because its benefits directly addressed Nimbus's primary objectives, while its limitations were considered acceptable for the target use case. The significant reduction in operational overhead, the cost model optimized for sporadic usage, and the ease of packaging complex dependencies via Docker outweighed the constraints on execution time and resources. While Fargate offered more flexibility in some areas, its orchestration requirements and less granular pricing model presented potential barriers to the simplicity and cost-effectiveness Nimbus aims to provide. Therefore, Lambda provided the optimal balance, best embodying Nimbus's value proposition of abstraction and simplicity for individual developers and small teams deploying task-specific NLP models."}),"\n",(0,n.jsx)("figure",{children:(0,n.jsx)("img",{src:"/img/LambdaFargateComparison.png",className:"image",alt:"lambda vs fargate image",width:"80%"})}),"\n",(0,n.jsx)(i.h2,{id:"aws-cdk-vs-aws-sdk",children:"AWS CDK vs. AWS SDK"}),"\n",(0,n.jsxs)(i.p,{children:["The team also evaluated how Nimbus would define and manage cloud infrastructure, including API Gateway and Lambda functions. The choice lay between direct interaction via the ",(0,n.jsx)(i.strong,{children:"AWS SDK (Software Development Kit)"})," and a higher-level abstraction using the ",(0,n.jsx)(i.strong,{children:"AWS CDK (Cloud Development Kit)"}),"."]}),"\n",(0,n.jsx)("figure",{children:(0,n.jsx)("img",{src:"/img/cdkVsSdk.png",className:"image",alt:"cdk vs sdk image",width:"70%"})}),"\n",(0,n.jsx)(i.h3,{id:"aws-sdk",children:"AWS SDK"}),"\n",(0,n.jsxs)(i.p,{children:["Using the AWS SDK would involve making direct API calls to AWS services. This ",(0,n.jsx)(i.strong,{children:"imperative approach"})," could potentially allow for faster initial infrastructure provisioning times, as resources are created immediately via API interactions without an intermediate synthesis step. This was confirmed during the creation of a prototype utilizing the SDK for our infrastructure management, where we did see faster provisioning, often with deployment occurring in under a minute."]}),"\n",(0,n.jsxs)(i.p,{children:["This method, however, presented significant drawbacks that were misaligned with Nimbus's goals. For example, using the SDK would require ",(0,n.jsx)(i.strong,{children:"manual management"})," of resource creation, tracking, and updates. Of particular importance, the absence of state tracking could result in deployments facing a high risk of infrastructure misalignment where the actual infrastructure could easily become inconsistent with the intended configuration, especially across multiple updates. This lack of state management would hinder reliability and repeatability."]}),"\n",(0,n.jsx)("figure",{children:(0,n.jsx)("img",{src:"/img/sdkToAWS.png",className:"image",alt:" sdk image",width:"70%"})}),"\n",(0,n.jsx)(i.h3,{id:"aws-cdk",children:"AWS CDK"}),"\n",(0,n.jsxs)(i.p,{children:["Our team ultimately chose to adopt the ",(0,n.jsx)(i.strong,{children:"AWS Cloud Development Kit (CDK)"})," as the standard for infrastructure provisioning. This decision prioritized long-term maintainability, reliability, and a better developer experience for managing cloud resources."]}),"\n",(0,n.jsxs)(i.p,{children:["The CDK facilitates a ",(0,n.jsx)(i.strong,{children:"declarative Infrastructure as Code (IaC)"})," approach, synthesizing code into AWS CloudFormation templates while providing ",(0,n.jsx)(i.strong,{children:"reliable state management"})," and ensuring repeatable deployments with safer updates. Furthermore, its ",(0,n.jsx)(i.strong,{children:"integrated deployment flow"})," fits naturally into Nimbus\u2019s CLI-driven workflow, offering safeguards like dependency resolution and automated rollback mechanisms. Finally, using CDK or other IaC tools are considered best-practice when provisioning AWS-specific infrastructure. Deployment times using the CDK generally occur within minutes."]}),"\n",(0,n.jsx)("figure",{children:(0,n.jsx)("img",{src:"/img/CDKtoAWS.png",className:"image",alt:"CDK image",width:"70%"})}),"\n",(0,n.jsx)(i.h3,{id:"justification-for-choosing-cdk",children:"Justification for Choosing CDK"}),"\n",(0,n.jsx)(i.p,{children:"Although using CDK introduces a slightly longer initial deployment time due to the CloudFormation synthesis step, compared to direct SDK calls, this trade-off was deemed acceptable. The CDK\u2019s declarative, idempotent infrastructure model ensures that repeated deployments always converge to the same final state, minimizing the risk of drift or inconsistent environments. This, combined with robust state management, improved maintainability, and a developer-friendly abstraction, outweighs the minor speed difference. These features directly benefit Nimbus\u2019s target audience by ensuring infrastructure predictability and consistency, while reducing the burden of manual cloud resource management, fitting perfectly with the project\u2019s emphasis on simplicity, and repeatability."}),"\n",(0,n.jsx)(i.h2,{id:"state-management-local-vs-cloud",children:"State Management: Local vs Cloud"}),"\n",(0,n.jsx)(i.p,{children:"Managing deployment state was another key architectural decision; specifically, we needed to decide how Nimbus would keep track of which models were deployed and their associated metadata (like model types, descriptions and endpoints). Two main approaches were evaluated: using a cloud-based database or a local configuration file."}),"\n",(0,n.jsx)("figure",{children:(0,n.jsx)("img",{src:"/img/localStorageVsCloud.png",className:"image",alt:"loacal storage vs cloud image",width:"70%"})}),"\n",(0,n.jsx)(i.h3,{id:"cloud-based-state-management",children:"Cloud-Based State Management"}),"\n",(0,n.jsx)(i.p,{children:"Using a cloud-backed datastore like AWS DynamoDB for tracking deployment state offered potential advantages, particularly for larger-scale scenarios:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Scalability:"})," Cloud databases are designed to handle growth, making them suitable for large teams or applications with many concurrent users managing deployments."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Shared Visibility:"})," A centralized cloud database provides a single source of truth, allowing team-wide visibility into the current deployment status and facilitating collaboration in deployments."]}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"This approach, however, was not utilized for Nimbus due to several factors that conflicted with its core design principles:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Added Complexity:"})," Implementing cloud-based state management would introduce additional overhead. This includes setting up and managing cloud resources, handling potential state synchronization issues between local actions and the cloud state, and managing the cloud-side logic itself."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Extra Cost:"})," Leveraging cloud services incurs ongoing operational costs for storage, read/write operations, and potentially data transfer. Even if not significant, this still adds a financial burden that is unnecessary for Nimbus's target use case."]}),"\n"]}),"\n",(0,n.jsx)(i.h3,{id:"local-configuration-file",children:"Local Configuration File"}),"\n",(0,n.jsx)(i.p,{children:"Nimbus adopted a simpler approach, utilizing a local configuration file named models.json stored within the user's local artifact directory to maintain deployment state. This method was selected based on its alignment with Nimbus's goals:"}),"\n",(0,n.jsxs)(i.ul,{children:["\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Simplicity:"})," A local JSON file is easy for developers to understand, inspect, and edit if necessary. The structure is simple, and therefore the learning curve is not steep."]}),"\n",(0,n.jsxs)(i.li,{children:[(0,n.jsx)(i.strong,{children:"Minimal Operational Burden:"})," As stated above, this approach avoids the need to provision, configure, or pay for external cloud infrastructure solely for state tracking."]}),"\n"]}),"\n",(0,n.jsx)(i.p,{children:"This local file strategy operates under the reasonable assumption that for Nimbus's primary user base (individual developers or small teams), the same person or group training a model is also responsible for deploying it. Therefore, the need for centralized, real-time state synchronization is less critical than simplicity and cost-effectiveness."}),"\n",(0,n.jsx)("figure",{children:(0,n.jsx)("img",{src:"/img/LocalFileStorage.png",className:"image",alt:"loacal file storage image",width:"70%"})})]})}function m(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,i,a)=>{a.d(i,{R:()=>r,x:()=>o});var t=a(6540);const n={},s=t.createContext(n);function r(e){const i=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);