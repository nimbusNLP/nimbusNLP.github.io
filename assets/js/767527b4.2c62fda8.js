"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[663],{5789:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"tradeoffs","title":"Trade-offs and Challenges","description":"Compute Layer: Container Hosting on EC2/Fargate vs. Dockerized Lambda","source":"@site/docs/tradeoffsAndChallenges.md","sourceDirName":".","slug":"/tradeoffs","permalink":"/docs/tradeoffs","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"id":"tradeoffs","sidebar_label":"5. Trade-offs & Challenges","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"4. architecture","permalink":"/docs/architecture"},"next":{"title":"6. Future Work","permalink":"/docs/futureWorkd"}}');var t=n(4848),s=n(8453);const o={id:"tradeoffs",sidebar_label:"5. Trade-offs & Challenges",sidebar_position:5},r="Trade-offs and Challenges",l={},d=[{value:"Compute Layer: Container Hosting on EC2/Fargate vs. Dockerized Lambda",id:"compute-layer-container-hosting-on-ec2fargate-vs-dockerized-lambda",level:2},{value:"Option 1: ECS with Fargate",id:"option-1-ecs-with-fargate",level:3},{value:"Option 2: Dockerized AWS Lambda (Chosen Approach)",id:"option-2-dockerized-aws-lambda-chosen-approach",level:3},{value:"Justification for Choosing Lambda",id:"justification-for-choosing-lambda",level:3},{value:"Infrastructure Definition: AWS CDK vs. AWS SDK",id:"infrastructure-definition-aws-cdk-vs-aws-sdk",level:2},{value:"Option 1: AWS SDK (Direct API Calls)",id:"option-1-aws-sdk-direct-api-calls",level:3},{value:"Option 2: AWS CDK (Chosen Approach)",id:"option-2-aws-cdk-chosen-approach",level:3},{value:"Justification for Choosing CDK",id:"justification-for-choosing-cdk",level:3},{value:"Deployment State Management: Local File vs. Cloud-Based Tracking",id:"deployment-state-management-local-file-vs-cloud-based-tracking",level:2},{value:"Option 1: Cloud-Based State Management (e.g., DynamoDB)",id:"option-1-cloud-based-state-management-eg-dynamodb",level:3},{value:"Option 2: Local Configuration File (Chosen Approach)",id:"option-2-local-configuration-file-chosen-approach",level:3}];function c(e){const i={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"trade-offs-and-challenges",children:"Trade-offs and Challenges"})}),"\n",(0,t.jsx)(i.h2,{id:"compute-layer-container-hosting-on-ec2fargate-vs-dockerized-lambda",children:"Compute Layer: Container Hosting on EC2/Fargate vs. Dockerized Lambda"}),"\n",(0,t.jsxs)(i.p,{children:["Selecting the appropriate compute layer for model inference was a critical architectural decision for Nimbus, balancing scalability, cost, and operational simplicity. The team evaluated options ranging from traditional container hosting to fully serverless functions, ultimately comparing two primary serverless strategies: ",(0,t.jsx)(i.strong,{children:"AWS Elastic Container Service (ECS) with Fargate"})," and ",(0,t.jsx)(i.strong,{children:"Dockerized AWS Lambda"})," functions."]}),"\n",(0,t.jsx)(i.h3,{id:"option-1-ecs-with-fargate",children:"Option 1: ECS with Fargate"}),"\n",(0,t.jsxs)(i.p,{children:["Using ",(0,t.jsx)(i.strong,{children:"ECS with Fargate"})," offers a serverless compute engine for containers, removing the need to manage underlying EC2 instances directly. This approach provides a familiar container-based workflow, potentially appealing to teams with existing containerization experience. Its advantages include greater flexibility than Lambda in terms of maximum execution duration and more traditional networking configurations."]}),"\n",(0,t.jsxs)(i.p,{children:["However, for Nimbus's specific goals, several drawbacks were identified. Fargate still necessitates managing ECS task definitions and services, introducing a layer of ",(0,t.jsx)(i.strong,{children:"orchestration overhead"})," that contrasts with Nimbus's aim for maximum simplicity. Furthermore, its pricing model (per vCPU/memory per second, often with minimum durations) could prove less cost-effective than Lambda for the highly ",(0,t.jsx)(i.strong,{children:"intermittent, low-traffic workloads"})," anticipated for Nimbus users, potentially incurring costs even during ",(0,t.jsx)(i.strong,{children:"idle periods"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["[",(0,t.jsx)(i.strong,{children:"IMAGE_TODO"}),": Image of ECS Fargate vs Lambda logos]"]}),"\n",(0,t.jsx)(i.p,{children:"![][image33]"}),"\n",(0,t.jsx)(i.h3,{id:"option-2-dockerized-aws-lambda-chosen-approach",children:"Option 2: Dockerized AWS Lambda (Chosen Approach)"}),"\n",(0,t.jsxs)(i.p,{children:["The team ultimately selected ",(0,t.jsx)(i.strong,{children:"Dockerized AWS Lambda"})," as the compute layer, determining it aligned most strongly with Nimbus\u2019s core goals of maximizing ",(0,t.jsx)(i.strong,{children:"simplicity"})," and ",(0,t.jsx)(i.strong,{children:"cost-efficiency"})," for users deploying lightweight models. As a fully managed function-as-a-service platform, Lambda entirely abstracts away server and orchestration concerns."]}),"\n",(0,t.jsxs)(i.p,{children:["The key advantages driving this decision were Lambda's ",(0,t.jsx)(i.strong,{children:"automatic scaling"})," based on demand (from zero upwards), its true ",(0,t.jsx)(i.strong,{children:"pay-per-invocation cost model"})," (billed per millisecond, ideal for intermittent traffic), and the elimination of infrastructure management. Crucially, Lambda's support for ",(0,t.jsx)(i.strong,{children:"Docker container images"})," allows users to reliably package complex Python dependencies (like spaCy) using familiar tooling, overcoming traditional deployment package limitations. Additionally, the ",(0,t.jsx)(i.strong,{children:"seamless integration"})," with API Gateway, provisioned via Nimbus's AWS CDK stack, simplifies exposing models as secure HTTP endpoints."]}),"\n",(0,t.jsxs)(i.p,{children:["This choice required accepting certain ",(0,t.jsx)(i.strong,{children:"trade-offs"})," inherent to Lambda. These include the 15-minute maximum execution duration, memory limits (up to 10GB), lack of direct GPU access, and the potential for ",(0,t.jsx)(i.strong,{children:"cold start latency"})," on infrequent invocations."]}),"\n",(0,t.jsx)(i.p,{children:"![][image34]"}),"\n",(0,t.jsx)(i.h3,{id:"justification-for-choosing-lambda",children:"Justification for Choosing Lambda"}),"\n",(0,t.jsx)(i.p,{children:"After evaluating both options, the Dockerized Lambda approach was chosen because its benefits directly addressed Nimbus's primary objectives, while its limitations were considered acceptable for the target use case. The significant reduction in operational overhead, the cost model optimized for sporadic usage, and the ease of packaging complex dependencies via Docker outweighed the constraints on execution time and resources. While Fargate offered more flexibility in some areas, its orchestration requirements and less granular pricing model presented potential barriers to the simplicity and cost-effectiveness Nimbus aims to provide. Therefore, Lambda provided the optimal balance, best embodying Nimbus's value proposition of abstraction and simplicity for individual developers and small teams deploying task-specific NLP models."}),"\n",(0,t.jsxs)(i.p,{children:["[",(0,t.jsx)(i.strong,{children:"IMAGE_TODO"}),": Summarize our decision?]"]}),"\n",(0,t.jsx)(i.h2,{id:"infrastructure-definition-aws-cdk-vs-aws-sdk",children:"Infrastructure Definition: AWS CDK vs. AWS SDK"}),"\n",(0,t.jsxs)(i.p,{children:["The team also evaluated how Nimbus would define and manage cloud infrastructure, including API Gateway and Lambda functions. The choice lay between direct interaction via the ",(0,t.jsx)(i.strong,{children:"AWS SDK (Software Development Kit)"})," and a higher-level abstraction using the ",(0,t.jsx)(i.strong,{children:"AWS CDK (Cloud Development Kit)"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"![][image35]"}),"\n",(0,t.jsx)(i.h3,{id:"option-1-aws-sdk-direct-api-calls",children:"Option 1: AWS SDK (Direct API Calls)"}),"\n",(0,t.jsxs)(i.p,{children:["Using the AWS SDK would involve making direct API calls to AWS services. This ",(0,t.jsx)(i.strong,{children:"imperative approach"})," could potentially allow for faster initial infrastructure provisioning times, as resources are created immediately via API interactions without an intermediate synthesis step. We actually created a prototype wherein we utilized the SDK for our infrastructure management, where we did see faster provisioning."]}),"\n",(0,t.jsxs)(i.p,{children:["This method, however, presented significant drawbacks that were misaligned with Nimbus's goals. For example, using the SDK would require ",(0,t.jsx)(i.strong,{children:"manual management"})," of resource creation, tracking, and updates. Of particular importance, the absence of state tracking could result in deployments facing a high risk of infrastructure misalignment where the actual infrastructure could easily become inconsistent with the intended configuration, especially across multiple updates. This lack of state management hinders reliability and repeatability."]}),"\n",(0,t.jsxs)(i.p,{children:["[",(0,t.jsx)(i.strong,{children:"IMAGE_TODO"}),": direct call to AWS or something]"]}),"\n",(0,t.jsx)(i.h3,{id:"option-2-aws-cdk-chosen-approach",children:"Option 2: AWS CDK (Chosen Approach)"}),"\n",(0,t.jsxs)(i.p,{children:["Our team ultimately chose to adopt the ",(0,t.jsx)(i.strong,{children:"AWS Cloud Development Kit (CDK)"})," as the standard for infrastructure provisioning. This decision prioritized long-term maintainability, reliability, and a better developer experience for managing cloud resources."]}),"\n",(0,t.jsxs)(i.p,{children:["The CDK enables a ",(0,t.jsx)(i.strong,{children:"declarative Infrastructure as Code (IaC)"})," approach, synthesizing code into AWS CloudFormation templates while providing ",(0,t.jsx)(i.strong,{children:"reliable state management"})," and ensuring repeatable deployments with safer updates. Furthermore, its ",(0,t.jsx)(i.strong,{children:"integrated deployment flow"})," fits naturally into Nimbus\u2019s CLI-driven workflow, offering safeguards like dependency resolution and automated rollback mechanisms. Finally, utilizing CDK or other IaC tools are considered best-practice when provisioning AWS-specific infrastructure."]}),"\n",(0,t.jsxs)(i.p,{children:["[",(0,t.jsx)(i.strong,{children:"IMAGE_TODO"}),": CDK -> cloudformation -> aws]"]}),"\n",(0,t.jsx)(i.h3,{id:"justification-for-choosing-cdk",children:"Justification for Choosing CDK"}),"\n",(0,t.jsxs)(i.p,{children:["Although using CDK introduces a slightly longer initial deployment time due to the CloudFormation synthesis step compared to direct SDK calls, this trade-off was deemed acceptable. The benefits of ",(0,t.jsx)(i.strong,{children:"declarative definitions"}),", ",(0,t.jsx)(i.strong,{children:"robust state management"}),", ",(0,t.jsx)(i.strong,{children:"improved maintainability"}),", and a ",(0,t.jsx)(i.strong,{children:"developer-friendly abstraction"})," outweigh the minor speed difference we noted. These factors directly benefit Nimbus\u2019s target audience by ensuring infrastructure consistency and reducing the burden of manual cloud resource management, aligning with the project's emphasis on simplicity and reliability."]}),"\n",(0,t.jsx)(i.h2,{id:"deployment-state-management-local-file-vs-cloud-based-tracking",children:"Deployment State Management: Local File vs. Cloud-Based Tracking"}),"\n",(0,t.jsx)(i.p,{children:"Managing deployment state was another key architectural decision; phrased another way, we needed to decide how Nimbus would keep track of which models were deployed and their associated metadata (like model types, descriptions and endpoints). Two main approaches were evaluated: using a cloud-based database or a local configuration file."}),"\n",(0,t.jsx)(i.p,{children:"![][image36]"}),"\n",(0,t.jsxs)(i.p,{children:["[",(0,t.jsx)(i.strong,{children:"IMAGE_TODO"}),": local vs DynamoDB logos]"]}),"\n",(0,t.jsx)(i.h3,{id:"option-1-cloud-based-state-management-eg-dynamodb",children:"Option 1: Cloud-Based State Management (e.g., DynamoDB)"}),"\n",(0,t.jsx)(i.p,{children:"Using a cloud-backed datastore like AWS DynamoDB for tracking deployment state offered potential advantages, particularly for larger-scale scenarios:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Scalability:"})," Cloud databases are designed to handle growth, making them suitable for large teams or applications with many concurrent users managing deployments."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Shared Visibility:"})," A centralized cloud database provides a single source of truth, allowing team-wide visibility into the current deployment status and facilitating collaboration in deployments."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"This approach, however, was not utilized for Nimbus due to several factors that conflicted with its core design principles:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Added Complexity:"})," Implementing cloud-based state management would introduce additional overhead. This includes setting up and managing cloud resources, handling potential state synchronization issues between local actions and the cloud state, and managing the cloud-side logic itself."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Extra Cost:"})," Leveraging cloud services incurs ongoing operational costs for storage, read/write operations, and potentially data transfer. Even if not significant, this still adds a financial burden that is unnecessary for Nimbus's target use case."]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"option-2-local-configuration-file-chosen-approach",children:"Option 2: Local Configuration File (Chosen Approach)"}),"\n",(0,t.jsx)(i.p,{children:"Nimbus adopted a simpler approach, utilizing a local configuration file named models.json stored within the user's local artifact directory to maintain deployment state. This method was chosen for its alignment with Nimbus's goals:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Simplicity:"})," A local JSON file is easy for developers to understand, inspect, and edit if necessary. The structure is straightforward, minimizing the learning curve."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Minimal Operational Burden:"})," As stated above, this approach avoids the need to provision, configure, or pay for external cloud infrastructure solely for state tracking."]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"This local file strategy operates under the reasonable assumption that for Nimbus's primary user base (individual developers or small teams), the same person or group training a model is also responsible for deploying it. Therefore, the need for centralized, real-time state synchronization is less critical than simplicity and cost-effectiveness."}),"\n",(0,t.jsx)(i.p,{children:"![][image37]"})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>r});var a=n(6540);const t={},s=a.createContext(t);function o(e){const i=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),a.createElement(s.Provider,{value:i},e.children)}}}]);