<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-tradeoffs" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.6.3">
<title data-rh="true">Trade-offs and Challenges | Nimbus</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://nimbusNLP.github.io/img/nimbusMain.png"><meta data-rh="true" name="twitter:image" content="https://nimbusNLP.github.io/img/nimbusMain.png"><meta data-rh="true" property="og:url" content="https://nimbusNLP.github.io/docs/tradeoffs"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Trade-offs and Challenges | Nimbus"><meta data-rh="true" name="description" content="Container Hosting on EC2/Fargate vs. Dockerized Lambda"><meta data-rh="true" property="og:description" content="Container Hosting on EC2/Fargate vs. Dockerized Lambda"><link data-rh="true" rel="icon" href="/img/nimbusMain.png"><link data-rh="true" rel="canonical" href="https://nimbusNLP.github.io/docs/tradeoffs"><link data-rh="true" rel="alternate" href="https://nimbusNLP.github.io/docs/tradeoffs" hreflang="en"><link data-rh="true" rel="alternate" href="https://nimbusNLP.github.io/docs/tradeoffs" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.e1bdc479.css">
<script src="/assets/js/runtime~main.ca153bca.js" defer="defer"></script>
<script src="/assets/js/main.6263a42d.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/nimbusMain.png" alt="Nimbus Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/nimbusMain.png" alt="Nimbus Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Nimbus</b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/docs/introduction">CASE STUDY</a><a class="navbar__item navbar__link" href="/docs/walkthrough">WALKTHROUGH</a><a class="navbar__item navbar__link" href="/#team">TEAM</a><a href="https://github.com/nimbusNLP" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GITHUB<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/introduction">1. Introduction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/background">2. Background</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/deployment">3. Deployment - The Bridge to Value</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/architecture">4. Architecture</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/tradeoffs">5. Trade-offs &amp; Challenges</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/futureWork">6. Future Work</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/walkthrough">Walkthrough</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">5. Trade-offs &amp; Challenges</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Trade-offs and Challenges</h1></header>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="container-hosting-on-ec2fargate-vs-dockerized-lambda">Container Hosting on EC2/Fargate vs. Dockerized Lambda<a href="#container-hosting-on-ec2fargate-vs-dockerized-lambda" class="hash-link" aria-label="Direct link to Container Hosting on EC2/Fargate vs. Dockerized Lambda" title="Direct link to Container Hosting on EC2/Fargate vs. Dockerized Lambda">​</a></h2>
<p>Selecting the appropriate compute layer for model inference was a critical architectural decision for Nimbus, balancing scalability, cost, and operational simplicity. The team evaluated options ranging from traditional container hosting to fully serverless functions, ultimately comparing two primary serverless strategies: <strong>AWS Elastic Container Service (ECS) with Fargate</strong> and <strong>Dockerized AWS Lambda</strong> functions.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="ecs-with-fargate">ECS with Fargate<a href="#ecs-with-fargate" class="hash-link" aria-label="Direct link to ECS with Fargate" title="Direct link to ECS with Fargate">​</a></h3>
<p>Using <strong>ECS with Fargate</strong> offers a serverless compute engine for containers, removing the need to manage underlying EC2 instances directly. This approach provides a familiar container-based workflow, potentially appealing to teams with existing containerization experience. Its advantages include greater flexibility than Lambda in terms of maximum execution duration and more traditional networking configurations.</p>
<p>However, for Nimbus&#x27;s specific goals, several drawbacks were identified. Fargate still necessitates managing ECS task definitions and services, introducing a layer of <strong>orchestration overhead</strong> that contrasts with Nimbus&#x27;s aim for maximum simplicity. Furthermore, its pricing model (per vCPU/memory per second, often with minimum durations) could prove less cost-effective than Lambda for the highly <strong>intermittent, low-traffic workloads</strong> anticipated for Nimbus users, potentially incurring costs even during <strong>idle periods</strong>.</p>
<figure><img src="/img/ecsFargatevsLambda.png" class="image" alt="image" width="70%"></figure>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="dockerized-aws-lambda">Dockerized AWS Lambda<a href="#dockerized-aws-lambda" class="hash-link" aria-label="Direct link to Dockerized AWS Lambda" title="Direct link to Dockerized AWS Lambda">​</a></h3>
<p>The team ultimately selected <strong>Dockerized AWS Lambda</strong> as the compute layer, determining it aligned most strongly with Nimbus’s core goals of maximizing <strong>simplicity</strong> and <strong>cost-efficiency</strong> for users deploying lightweight models. As a fully managed function-as-a-service platform, Lambda entirely abstracts away server and orchestration concerns.</p>
<p>The key advantages driving this decision were Lambda&#x27;s <strong>automatic scaling</strong> based on demand (from zero upwards), its true <strong>pay-per-invocation cost model</strong> (billed per millisecond, ideal for intermittent traffic), and the elimination of infrastructure management. Crucially, Lambda&#x27;s support for <strong>Docker container images</strong> allows users to reliably package complex Python dependencies (like spaCy) using familiar tooling, overcoming traditional deployment package limitations. Additionally, the <strong>seamless integration</strong> with API Gateway, provisioned via Nimbus&#x27;s AWS CDK stack, simplifies exposing models as secure HTTP endpoints.</p>
<p>This choice required accepting certain <strong>trade-offs</strong> inherent to Lambda. These include the 15-minute maximum execution duration, memory limits (up to 10GB), lack of direct GPU access, and the potential for <strong>cold start latency</strong> on infrequent invocations.</p>
<figure><img src="/img/dockerizedLambda.png" class="image" alt="dockerized lambda image" width="30%"></figure>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="justification-for-choosing-lambda">Justification for Choosing Lambda<a href="#justification-for-choosing-lambda" class="hash-link" aria-label="Direct link to Justification for Choosing Lambda" title="Direct link to Justification for Choosing Lambda">​</a></h3>
<p>After evaluating both options, the Dockerized Lambda approach was chosen because its benefits directly addressed Nimbus&#x27;s primary objectives, while its limitations were considered acceptable for the target use case. The significant reduction in operational overhead, the cost model optimized for sporadic usage, and the ease of packaging complex dependencies via Docker outweighed the constraints on execution time and resources. While Fargate offered more flexibility in some areas, its orchestration requirements and less granular pricing model presented potential barriers to the simplicity and cost-effectiveness Nimbus aims to provide. Therefore, Lambda provided the optimal balance, best embodying Nimbus&#x27;s value proposition of abstraction and simplicity for individual developers and small teams deploying task-specific NLP models.</p>
<figure><img src="/img/LambdaFargateComparison.png" class="image" alt="lambda vs fargate image" width="80%"></figure>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="aws-cdk-vs-aws-sdk">AWS CDK vs. AWS SDK<a href="#aws-cdk-vs-aws-sdk" class="hash-link" aria-label="Direct link to AWS CDK vs. AWS SDK" title="Direct link to AWS CDK vs. AWS SDK">​</a></h2>
<p>The team also evaluated how Nimbus would define and manage cloud infrastructure, including API Gateway and Lambda functions. The choice lay between direct interaction via the <strong>AWS SDK (Software Development Kit)</strong> and a higher-level abstraction using the <strong>AWS CDK (Cloud Development Kit)</strong>.</p>
<figure><img src="/img/cdkVsSdk.png" class="image" alt="cdk vs sdk image" width="70%"></figure>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="aws-sdk">AWS SDK<a href="#aws-sdk" class="hash-link" aria-label="Direct link to AWS SDK" title="Direct link to AWS SDK">​</a></h3>
<p>Using the AWS SDK would involve making direct API calls to AWS services. This <strong>imperative approach</strong> could potentially allow for faster initial infrastructure provisioning times, as resources are created immediately via API interactions without an intermediate synthesis step. This was confirmed during the creation of a prototype utilizing the SDK for our infrastructure management, where we did see faster provisioning, often with deployment occurring in under a minute.</p>
<p>This method, however, presented significant drawbacks that were misaligned with Nimbus&#x27;s goals. For example, using the SDK would require <strong>manual management</strong> of resource creation, tracking, and updates. Of particular importance, the absence of state tracking could result in deployments facing a high risk of infrastructure misalignment where the actual infrastructure could easily become inconsistent with the intended configuration, especially across multiple updates. This lack of state management would hinder reliability and repeatability.</p>
<figure><img src="/img/sdkToAWS.png" class="image" alt=" sdk image" width="70%"></figure>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="aws-cdk">AWS CDK<a href="#aws-cdk" class="hash-link" aria-label="Direct link to AWS CDK" title="Direct link to AWS CDK">​</a></h3>
<p>Our team ultimately chose to adopt the <strong>AWS Cloud Development Kit (CDK)</strong> as the standard for infrastructure provisioning. This decision prioritized long-term maintainability, reliability, and a better developer experience for managing cloud resources.</p>
<p>The CDK facilitates a <strong>declarative Infrastructure as Code (IaC)</strong> approach, synthesizing code into AWS CloudFormation templates while providing <strong>reliable state management</strong> and ensuring repeatable deployments with safer updates. Furthermore, its <strong>integrated deployment flow</strong> fits naturally into Nimbus’s CLI-driven workflow, offering safeguards like dependency resolution and automated rollback mechanisms. Finally, using CDK or other IaC tools are considered best-practice when provisioning AWS-specific infrastructure. Deployment times using the CDK generally occur within minutes.</p>
<figure><img src="/img/CDKtoAWS.png" class="image" alt="CDK image" width="70%"></figure>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="justification-for-choosing-cdk">Justification for Choosing CDK<a href="#justification-for-choosing-cdk" class="hash-link" aria-label="Direct link to Justification for Choosing CDK" title="Direct link to Justification for Choosing CDK">​</a></h3>
<p>Although using CDK introduces a slightly longer initial deployment time due to the CloudFormation synthesis step, compared to direct SDK calls, this trade-off was deemed acceptable. The CDK’s declarative, idempotent infrastructure model ensures that repeated deployments always converge to the same final state, minimizing the risk of drift or inconsistent environments. This, combined with robust state management, improved maintainability, and a developer-friendly abstraction, outweighs the minor speed difference. These features directly benefit Nimbus’s target audience by ensuring infrastructure predictability and consistency, while reducing the burden of manual cloud resource management, fitting perfectly with the project’s emphasis on simplicity, and repeatability.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="state-management-local-vs-cloud">State Management: Local vs Cloud<a href="#state-management-local-vs-cloud" class="hash-link" aria-label="Direct link to State Management: Local vs Cloud" title="Direct link to State Management: Local vs Cloud">​</a></h2>
<p>Managing deployment state was another key architectural decision; specifically, we needed to decide how Nimbus would keep track of which models were deployed and their associated metadata (like model types, descriptions and endpoints). Two main approaches were evaluated: using a cloud-based database or a local configuration file.</p>
<figure><img src="/img/localStorageVsCloud.png" class="image" alt="loacal storage vs cloud image" width="70%"></figure>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="cloud-based-state-management">Cloud-Based State Management<a href="#cloud-based-state-management" class="hash-link" aria-label="Direct link to Cloud-Based State Management" title="Direct link to Cloud-Based State Management">​</a></h3>
<p>Using a cloud-backed datastore like AWS DynamoDB for tracking deployment state offered potential advantages, particularly for larger-scale scenarios:</p>
<ul>
<li><strong>Scalability:</strong> Cloud databases are designed to handle growth, making them suitable for large teams or applications with many concurrent users managing deployments.</li>
<li><strong>Shared Visibility:</strong> A centralized cloud database provides a single source of truth, allowing team-wide visibility into the current deployment status and facilitating collaboration in deployments.</li>
</ul>
<p>This approach, however, was not utilized for Nimbus due to several factors that conflicted with its core design principles:</p>
<ul>
<li><strong>Added Complexity:</strong> Implementing cloud-based state management would introduce additional overhead. This includes setting up and managing cloud resources, handling potential state synchronization issues between local actions and the cloud state, and managing the cloud-side logic itself.</li>
<li><strong>Extra Cost:</strong> Leveraging cloud services incurs ongoing operational costs for storage, read/write operations, and potentially data transfer. Even if not significant, this still adds a financial burden that is unnecessary for Nimbus&#x27;s target use case.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="local-configuration-file">Local Configuration File<a href="#local-configuration-file" class="hash-link" aria-label="Direct link to Local Configuration File" title="Direct link to Local Configuration File">​</a></h3>
<p>Nimbus adopted a simpler approach, utilizing a local configuration file named models.json stored within the user&#x27;s local artifact directory to maintain deployment state. This method was selected based on its alignment with Nimbus&#x27;s goals:</p>
<ul>
<li><strong>Simplicity:</strong> A local JSON file is easy for developers to understand, inspect, and edit if necessary. The structure is simple, and therefore the learning curve is not steep.</li>
<li><strong>Minimal Operational Burden:</strong> As stated above, this approach avoids the need to provision, configure, or pay for external cloud infrastructure solely for state tracking.</li>
</ul>
<p>This local file strategy operates under the reasonable assumption that for Nimbus&#x27;s primary user base (individual developers or small teams), the same person or group training a model is also responsible for deploying it. Therefore, the need for centralized, real-time state synchronization is less critical than simplicity and cost-effectiveness.</p>
<figure><img src="/img/LocalFileStorage.png" class="image" alt="loacal file storage image" width="70%"></figure></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/architecture"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">4. Architecture</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/futureWork"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">6. Future Work</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#container-hosting-on-ec2fargate-vs-dockerized-lambda" class="table-of-contents__link toc-highlight">Container Hosting on EC2/Fargate vs. Dockerized Lambda</a><ul><li><a href="#ecs-with-fargate" class="table-of-contents__link toc-highlight">ECS with Fargate</a></li><li><a href="#dockerized-aws-lambda" class="table-of-contents__link toc-highlight">Dockerized AWS Lambda</a></li><li><a href="#justification-for-choosing-lambda" class="table-of-contents__link toc-highlight">Justification for Choosing Lambda</a></li></ul></li><li><a href="#aws-cdk-vs-aws-sdk" class="table-of-contents__link toc-highlight">AWS CDK vs. AWS SDK</a><ul><li><a href="#aws-sdk" class="table-of-contents__link toc-highlight">AWS SDK</a></li><li><a href="#aws-cdk" class="table-of-contents__link toc-highlight">AWS CDK</a></li><li><a href="#justification-for-choosing-cdk" class="table-of-contents__link toc-highlight">Justification for Choosing CDK</a></li></ul></li><li><a href="#state-management-local-vs-cloud" class="table-of-contents__link toc-highlight">State Management: Local vs Cloud</a><ul><li><a href="#cloud-based-state-management" class="table-of-contents__link toc-highlight">Cloud-Based State Management</a></li><li><a href="#local-configuration-file" class="table-of-contents__link toc-highlight">Local Configuration File</a></li></ul></li></ul></div></div></div></div></main></div></div></div></div>
</body>
</html>